**User Documentation**
----------------------

### **Overview**

This program was created during the winter semester 2024/25 at the **University of Vienna** for the course **"2024W 053531-1 Softwareentwicklungsprojekt Bioinformatik"**, by **Theodora Beshara** and **Sebastian Rossböck**.

The program reads protein IDs from a **FASTA-formatted** file and retrieves annotations for each protein from **UniProt** and **Pfam**. Using **BioBERT**, it generates embeddings for these annotations and then compares and visualizes the results.

### **Compatibility**

This project was set up using **Python 3.11.9** and **Visual Studio**. If you choose to run this program in a different environment, please disregard the next section.

The libraries listed in **requirements.txt** are required to run this program. Please install them using your preferred method.

### **Setting up the environment**

When **Python** and **Visual Studio Code** are installed, we will need to set up a Python environment and install the libraries we will use.

In **Visual Studio Code**, open the folder that contains the repository.

In the terminal (**Str+Ö** or **View → Terminal**) type:

**python -m venv .venv**

This sets up the Python environment.

After that, install the necessary libraries by typing:

**pip install -r requirements.txt**

in the terminal.

### **Running the program**

In general, steps one through six will create a list of **AnnotationData** objects that collect the relevant information for each protein. The list of objects will be serialized at various points in the program. With the configuration settings, it is possible to set up the program to skip steps that have already been completed. Fetching the annotations can be a time-consuming task.

#### **1. ****Config**

The **biobert.ini** file contains multiple parameters to configure the program. These settings are loaded at the start of execution.

-   **fasta_file** : The file location for the FASTA file that contains the IDs of the proteins to be processed.
-   **annotation_file_input** : The file location for the annotation data when loading the data from a file.
-   **annotation_file_output** : The file location for the annotation data without embeddings.
-   **annotation_embedding_file_output** : The file location for the annotation data, including embeddings.
-   **data_eval_output** : The file location for the result of the data evaluation.
-   **loadAnnotationsFromFile** (boolean) : Specifies whether the annotation data should be loaded from a file or fetched from the APIs.
-   **getPfamEmbeddings** (boolean) : Specifies whether embeddings for the Pfam annotations should be generated.
-   **getUniProtEmbeddings** (boolean) : Specifies whether embeddings for the UniProt annotations should be generated.
-   **model** : The name of the model that will be loaded.
-   **distances_plot_output **: The file location where the cosine distance plot will be saved.
-   **tsne_plot_output **: The file location where the tsne plost will be saved.

#### **2.1 Loading annotations**

If the corresponding configuration is set, the **AnnotationData** will be loaded from a file. When the program runs, a file is created after fetching the data from the APIs. The process of fetching annotations is quite time-consuming since they are retrieved sequentially. It is recommended to load the data from a file once it has been fetched.

#### **2.2 Fetching annotations**

For each **RefSeq identifier** in the FASTA file, it is converted to a **UniProtKB ID**. The annotations are then retrieved from **UniProt** and **Pfam** via their respective APIs, and a list of **AnnotationData** objects is created.

These objects store the relevant information for the nucleotide sequences, including:

-   **UniProt ID**
-   **RefSeq ID**
-   **Pfam ID**
-   Annotations from **UniProt** and **Pfam**
-   **BioBERT embeddings** (added later in the process)

#### **3.  Evalutate Data**

The annotations are evaluated by analyzing their **average length**, **maximum**, **minimum**, and **missing annotations**. The results are then saved in the location specified by the **data_eval_output** setting.

#### **3.5 Clean Data**

For our purpose, only proteins that have both **Pfam** and **UniProt** annotations can be used. Additionally, annotations must not exceed **512 words**, as the **BioBERT** model would truncate any longer annotations, resulting in incomplete data.

For these reasons, all **AnnotationData** objects that do not meet these criteria are removed in this step.

#### **4. Generate Encodings**

For each annotation, an embedding is generated by passing the data through the model and then saving the embedding in the respective **AnnotationData** object.

**inputs = tokenizer(textInput, return_tensors="pt", padding=True, truncation=True, max_length=512)**

**# Forward pass through the model**\
**with torch.no_grad():**\
  **outputs = model(**inputs)**

**# Extract embeddings (CLS token representations)**\
**embeddings = outputs.last_hidden_state[:, 0, :]**

This data is then saved to the path specified in **annotation_embedding_file_output**. Since this file is too large to upload to GitHub, it has to be created locally. It can be reused after being created once, allowing the first four steps of the program to be skipped.

#### **5. Calculate the distance between embeddings**

For each protein, the distance between the embeddings of the **UniProt** and **Pfam** annotations is computed using **cosine similarity**. Since embeddings can be represented as high-dimensional vectors, cosine similarity measures how similar the "direction" of the two vectors is. A plot of a histogram and the min, max and average distance is created.\
The resulting plot is saved to the location specified in the **biobert.ini** file.

The value for distance ranges from 0 to 2. A distance of 0 means that the vectors are identical, 1 means orthogonal and 2 means the vectors are opposite.

#### **6\. ****Visualization of Embeddings**

To better understand the relationships between protein annotations, **t-Distributed Stochastic Neighbor Embedding (t-SNE)** is applied to visualize the high-dimensional embeddings in a two-dimensional space. The program allows visualization of either **Pfam** or **UniProt** embeddings. By default, **Pfam embeddings** are selected, but this can be changed in the code.

t-SNE reduces the dimensionality of data while preserving local relationships between points. The transformation is applied with the following parameters:

-   **n_components = 2** (reducing the embeddings to two dimensions)
-   **perplexity = 30** (balances local and global aspects of the data)
-   **learning_rate = 200**
-   **max_iter = 5000**
-   **random_state = 42** (ensures reproducibility)

After the transformation, a **DataFrame** is created, storing the computed t-SNE coordinates along with protein names and annotation labels.

The visualization is performed using two methods: **Matplotlib** and **Plotly**. A static **scatter plot** is generated with **Matplotlib**, where each point represents a protein annotation in the transformed space. Labels and colors can be customized to enhance interpretability. Additionally, an **interactive visualization** is created using **Plotly**, allowing users to explore the data by hovering over points to reveal protein names and annotation details.

For further analysis, **K-Means clustering** can be applied to group proteins with similar annotation embeddings. The number of clusters is configurable (default: 5). The clustered results are visualized in an **interactive Plotly scatter plot**, where each cluster is represented by a distinct color.

These visualizations provide insight into the similarities and differences between protein annotations and can assist in understanding how UniProt and Pfam embeddings relate to each other.
